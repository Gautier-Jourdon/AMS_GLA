% Cahier des charges – Projet AMS GLA
\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{setspace}
\onehalfspacing

\title{Cahier des charges\\Projet AMS GLA}
\author{Gautier Jourdon}
\date{\today}

\begin{document}
\maketitle

\section{Contexte et objectifs}

Ce document présente, de manière synthétique, le cahier des charges du projet AMS GLA tel qu’il ressort du sujet et de l’état actuel du dépôt \texttt{AMS\_GLA}. Il sert de référence pour expliquer ce que l’application doit faire, dans quelles conditions techniques elle doit fonctionner et quels livrables sont attendus.

Le projet consiste à mettre en place un collecteur de données écrit en Node.js. Ce collecteur suit un ensemble d’actifs (par exemple des cryptomonnaies ou des actions) et interroge régulièrement des API externes, comme l’API CoinCap, afin de récupérer leurs valeurs. Le travail est réalisé en individuel, dans le cadre du module AMS / GLA, avec une logique de déploiement moderne basée sur les conteneurs (Docker, éventuellement Kubernetes) et une exigence minimale de qualité de code via des tests unitaires. En complément du code, un rapport doit décrire la démarche, les choix effectués et l’organisation du projet.

Les objectifs globaux du projet sont donc les suivants :
\begin{itemize}
	\item disposer d’un collecteur automatique de données sur des actifs financiers ou cryptographiques ;
	\item garantir un minimum de robustesse et de qualité grâce aux tests unitaires ;
	\item préparer le déploiement dans un environnement conteneurisé (Docker, Kubernetes) ;
	\item fournir un rapport expliquant la conception et la démarche de réalisation.
\end{itemize}

\section{Besoins fonctionnels}

Sur le plan fonctionnel, l’application doit d’abord être capable de gérer une liste d’actifs à suivre. Cette liste est définie dans un fichier de configuration, par exemple \texttt{collector/data/assets.json}, qui précise quels actifs doivent être collectés. Pour chaque actif, le collecteur interroge périodiquement l’API distante au moyen d’un service dédié, comme \texttt{coincapService.js}. Il ne s’agit pas uniquement de faire un appel réussi dans le cas idéal : le collecteur doit également prendre en compte les erreurs réseau (timeouts, indisponibilité de l’API, codes HTTP d’erreur) et les cas où les données renvoyées sont incomplètes ou incohérentes.

L’exécution de cette collecte ne doit pas rester purement manuelle. Le cahier des charges prévoit qu’elle soit automatisée à intervalles réguliers, par exemple grâce à un système de planification de type cron implémenté dans \texttt{utils/cron.js}. Il doit cependant rester possible de lancer la collecte manuellement, avec un simple script Node, afin de faciliter les tests et le débogage. Cette double possibilité (planification automatique et lancement manuel) permet à la fois d’industrialiser la solution et de la rendre confortable à développer.

Une fois les données récupérées, l’application doit les stocker ou les exposer de manière claire. Selon les contraintes exactes du sujet, cette sortie peut prendre la forme d’un fichier, de simples logs console ou d’un futur service API. Dans tous les cas, le format de sortie doit être explicite et cohérent : chaque mesure doit être associée au moins à un horodatage, à l’identifiant de l’actif concerné et à une ou plusieurs valeurs collectées. Cette structuration est essentielle pour pouvoir exploiter ou analyser les données par la suite.

En résumé, les principaux besoins fonctionnels sont :
\begin{itemize}
	\item la gestion d’une liste d’actifs à surveiller ;
	\item la collecte régulière de données auprès d’une API externe ;
	\item la gestion des erreurs de communication ;
	\item la mise à disposition d’une sortie de données claire et exploitable.
\end{itemize}

\section{Contraintes techniques et non fonctionnelles}

Le projet impose également des exigences de qualité. L’usage du framework Jest est prévu pour écrire des tests unitaires. Ces tests doivent couvrir a minima la lecture de la configuration (par exemple à partir d’\texttt{assets.json}), le comportement du fetcher et la gestion des erreurs lors des appels à l’API. L’objectif n’est pas d’atteindre une couverture parfaite, mais de garantir un socle de fiabilité sur les parties critiques : configuration, communication réseau et logique de collecte.

Sur le plan technique, le langage retenu est Node.js, dans la version indiquée dans \texttt{package.json}. Des bibliothèques telles que \texttt{node-fetch} (ou équivalent) peuvent être utilisées pour réaliser les appels HTTP, tandis qu’une librairie de type \texttt{node-cron} (ou une implémentation maison) peut servir pour la planification. La configuration non sensible (comme la liste des actifs) est gérée via des fichiers JSON, alors que les paramètres plus critiques (par exemple les clés d’API, les URL de base) doivent, dans l’idéal, être passés par des variables d’environnement. Le Dockerfile s’appuie sur une image Node LTS et, si nécessaire, peut être optimisé pour réduire la taille de l’image (par exemple en utilisant un multi-stage build).

Les contraintes non fonctionnelles complètent ce cadre. L’application doit être robuste : elle ne doit pas s’arrêter brutalement en cas d’erreur d’API ou de données incomplètes, et doit produire au minimum des logs clairs au niveau information et erreur. Les performances doivent être raisonnables pour un nombre classique d’actifs à suivre (quelques dizaines à quelques centaines) sans viser l’optimisation extrême. La maintenance doit être facilitée par une bonne organisation du code : séparation en dossiers \texttt{services/}, \texttt{utils/}, \texttt{data/}, et présence de tests automatisables via une simple commande \texttt{npm test}.

On peut résumer les principales contraintes techniques et non fonctionnelles ainsi :
\begin{itemize}
	\item utilisation de Node.js et de bibliothèques adaptées aux appels HTTP et à la planification ;
	\item configuration claire et sécurisée (fichiers JSON et variables d’environnement) ;
	\item robustesse face aux erreurs d’API et aux données incomplètes ;
	\item performances suffisantes pour un volume raisonnable d’actifs ;
	\item code structuré et testable, avec des tests unitaires automatisables.
\end{itemize}

\section{Livrables et état actuel}

Les livrables attendus sont multiples. On attend d’abord le code source complet dans le dépôt \texttt{AMS\_GLA}, accompagné de tests Jest fonctionnels. Le Dockerfile doit permettre de construire et de lancer le conteneur sans modification supplémentaire. Si le sujet le prévoit, un manifeste Kubernetes est fourni pour la planification. Enfin, un rapport AMS GLA accompagne le tout. Il décrit la conception, explique comment le projet a été organisé (notamment au travers de la méthode Kanban ou Agile retenue) et revient sur les difficultés rencontrées ainsi que sur les pistes d’amélioration.

Au moment de la rédaction de ce cahier des charges, plusieurs éléments sont déjà présents dans le dépôt : les fichiers \texttt{collector/index.js}, \texttt{collector/services/coincapService.js}, \texttt{collector/utils/fetcher.js} et \texttt{collector/utils/cron.js} constituent le squelette de l’application de collecte. Le fichier \texttt{collector/data/assets.json} propose une première configuration d’actifs à suivre. Le dossier \texttt{tests/} contient déjà un test Jest (\texttt{getAssets.test.js}), ce qui montre que la démarche de qualité a été entamée. Le \texttt{Dockerfile} et le fichier \texttt{k8s/collector/collector-cron.yaml} donnent une base de travail pour la conteneurisation et la planification Kubernetes. Enfin, le répertoire \texttt{Rapport/} contient une version en cours du rapport (\texttt{Rapport\_AMS\_GLA\_v2.pdf}).

Ce cahier des charges se veut volontairement clair et humain tout en respectant une structure classique (contexte, besoins, contraintes, livrables). Il peut être affiné ou enrichi directement à partir du sujet PDF officiel, en complétant notamment le contexte pédagogique, les cas d’usage précis ou les contraintes d’évaluation imposées par l’enseignant.

\end{document}
