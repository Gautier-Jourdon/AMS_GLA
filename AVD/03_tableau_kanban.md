# Tableau Kanban – AMS GLA

Le tableau Kanban utilisé pour le projet AMS GLA est volontairement simple, afin de rester adapté à un travail individuel. Il repose sur quelques colonnes essentielles qui représentent l’état d’avancement des différentes User Stories et tâches issues du backlog produit. Ce dispositif visuel peut être reproduit dans un outil comme Trello, GitHub Projects ou même sous forme de tableau dans le rapport, mais il peut aussi rester purement textuel, tant que sa logique est claire.

Dans ce Kanban, la colonne « Backlog » regroupe l’ensemble des tâches possibles, qu’elles soient fonctionnelles, techniques ou documentaires. C’est la réserve d’idées et d’objectifs potentiels. À partir de ce bassin global, certaines tâches sont sélectionnées pour être réellement travaillées sur une période donnée : elles passent alors dans la colonne « À faire ». Cette colonne représente le plan de travail à court terme, ce sur quoi on veut se concentrer dans les prochains jours.

Lorsque tu commences effectivement à travailler sur une tâche, elle bascule dans la colonne « En cours ». L’objectif, en Kanban, est de limiter le nombre d’éléments présents dans cette colonne pour éviter de se disperser. Idéalement, il ne devrait y avoir qu’une seule tâche en cours à la fois. Une fois le code écrit, que les premiers tests ont été lancés et que les éventuels ajustements sont en cours, la tâche peut passer en « En revue / Test ». Dans le cadre de ce projet, cette revue correspond souvent à l’exécution des tests Jest, à des essais manuels et à une vérification rapide de la cohérence globale. Enfin, une fois la tâche pleinement validée, elle est déplacée dans la colonne « Fait », qui matérialise le travail réellement terminé.

Si l’on regarde l’état estimé du Kanban à partir du dépôt actuel, plusieurs User Stories sont encore dans le Backlog ou n’ont pas été planifiées finement. C’est le cas par exemple de la gestion avancée des erreurs d’appel API (US3), de la définition d’un modèle de sortie homogène pour les données collectées (US4), de l’écriture des données dans un fichier ou un système de logs structuré (US7), de la formalisation des logs avec timestamp et identifiant d’actif (US8), de certains tests spécifiques liés aux erreurs et au cron (US11), ou encore de la conclusion et des perspectives du rapport (US16).

Dans la colonne « À faire », on retrouve généralement les prochaines priorités techniques immédiates : la finalisation du service d’appel à l’API CoinCap, incluant une meilleure gestion des paramètres et des erreurs de base (US2), la vérification et la complétion de la planification cron locale (US5), ainsi que la consolidation des tests unitaires existants, notamment ceux définis dans `getAssets.test.js` (US10). Ce sont les tâches qui doivent être traitées dans un horizon de temps court pour stabiliser le socle fonctionnel du projet.

La colonne « En cours » reflète les sujets actuellement travaillés. Elle peut par exemple contenir le Dockerfile, qui doit être vérifié de bout en bout (construction de l’image puis exécution) pour s’assurer qu’il permet réellement de lancer le collecteur (US12). On y trouve également le manifeste Kubernetes dédié à l’exécution planifiée, comme `collector-cron.yaml` (US13), ainsi que des éléments de documentation tels que la structuration du rapport AMS GLA (US14) et la description de la méthode Agile / Kanban (US15). Ces tâches sont au cœur de l’activité du moment et peuvent évoluer de jour en jour.

La colonne « En revue / Test » est généralement occupée par des éléments dont le développement est terminé mais qui nécessitent encore une validation, comme la configuration initiale de Jest (US9) ou le script de lancement manuel (US6), qui doit être testé proprement pour garantir un démarrage fluide de l’application. Enfin, la colonne « Fait » comprend les tâches définitivement terminées et validées, telles que la définition de la liste des actifs dans `assets.json` (US1) ou la mise en place de la configuration Jest et d’un premier test (US9).

Même dans un projet individuel, il est utile de définir quelques règles simples de fonctionnement du Kanban. La première concerne la limitation du travail en cours (Work In Progress, WIP) : on essaie de ne pas avoir plus d’une tâche active dans la colonne « En cours ». Si l’on se retrouve bloqué sur un point, la tâche peut être provisoirement considérée comme « Bloquée » (via une colonne ou une étiquette spécifique), et une autre tâche prioritaire peut alors être prise. Une autre règle touche à la priorisation : les éléments indispensables au fonctionnement (collecte, tests de base, Docker) sont traités avant les parties plus rédactionnelles du rapport.

Enfin, il est important de se donner une définition claire de ce que signifie « Fait » pour une User Story. Dans ce projet, une tâche est considérée comme terminée lorsque le code est écrit, que l’application s’exécute sans erreur et que les tests pertinents (par exemple `npm test`) passent avec succès. Une petite trace documentaire, sous forme de commentaire dans le code ou de note dans le rapport, vient idéalement compléter ce triptyque. En ajoutant dans ton rapport un court historique de l’évolution de ce tableau Kanban, semaine par semaine, tu montres la continuité de ton organisation et la progression concrète du projet.